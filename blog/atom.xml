<feed xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns="http://www.w3.org/2005/Atom">
      <title>Lagom Blog</title>
      <link rel="alternate" type="text/html" href="http://jroper.github.io/lagom.github.io/blog"/>
      <link rel="self" type="application/atom+xml" href="http://jroper.github.io/lagom.github.io/blog/atom.xml"/>
      <id>http://jroper.github.io/lagom.github.io/blog</id>
      <rights>Copyright 2017, Lightbend</rights>
      <updated>2017-02-24T11:00:00.000+11:00</updated>
      <dc:creator>Lightbend</dc:creator>
      <dc:date>2017-02-24T11:00:00.000+11:00</dc:date>
      <dc:language>en</dc:language>
      <dc:rights>Copyright 2017, Lightbend</dc:rights>
      <entry>
          <title>Lagom 1.3.0 is released!</title>
          <link rel="alternate" href="http://jroper.github.io/lagom.github.io/blog/lagom-1-3.html"/>
          <category term="news" scheme="http://jroper.github.io/lagom.github.io/blog/tags/news.html"/>
          <author>
            <name>James Roper</name>
            <uri>https://github.com/jroper</uri>
          </author>
          <id>http://jroper.github.io/lagom.github.io/blog/lagom-1-3.html</id>
          <updated>2017-02-24T11:00:00.000+11:00</updated>
          <published>2017-02-24T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>Lagom 1.3.0 has been released! This much anticipated release includes the new Lagom Scala API, an issue voted on by over <a href="https://github.com/lagom/lagom/issues/1">400 people</a>. In addition, it also includes JPA support, allowing developers familiar with a more traditional Java stack to ease their way into Lagom without having to relearn everything at once.</p>
<h2><a href="#scala-api" name="scala-api">Scala API</a></h2>
<p>The new Scala API provides feature parity with the Java API, meaning that both APIs are now first class citizens in the Lagom ecosystem. We are committed to providing a great microservices development framework for both languages, and this release is making good on that promise for Scala. Going forward with new features, in Lagom, the definition of done in Lagom is defined to mean that a feature is not complete unless it provides API and documentation parity for both the Scala and Java APIs.</p>
<p>Having said that the Scala and Java APIs have feature parity, this does not mean that the APIs and approaches used are identical. Our approach to creating Scala APIs in Lagom has been to provide Scala developers with more type safety and less reliance on reflection than the Java API uses. Some major differences therefore between the Scala API and Java API are:</p>
<ul>
  <li>Use of type class based serialization, based on play-json, rather than using Jackson&rsquo;s reflection based databind API.</li>
  <li>Use of compile time wired dependency injection, utilizing the cake pattern and <a href="https://github.com/adamw/macwire">MacWire</a>, rather than using Guice.</li>
  <li>Use of macros to implement service clients and to wire service implementations, rather than dynamic proxies and reflection.</li>
</ul>
<p>We feel that developers that have already bought into the increased type safety that using Scala can give will appreciate this difference in approach, and so it makes sense to differ the Scala and Java APIs in this way.</p>
<p>To get started with the Lagom Scala API, read our <a href="http://www.lagomframework.com/documentation/1.3.x/scala/Installation.html">getting started guide</a>.</p>
<h2><a href="#jpa-support" name="jpa-support">JPA support</a></h2>
<p>Lagom&rsquo;s new JPA support includes two important features:</p>
<ul>
  <li>Managed execution of interactions with a JPA entity manager.</li>
  <li>Read side processor support with automatic offset management.</li>
</ul>
<p>In a non blocking framework, the use of blocking APIs, such as JPA, can be very dangerous. A few database queries can easily hold up the entire application, and the interaction between thread pools and connection pools is prone to deadlocks. It&rsquo;s therefore important that any blocking operations are carefully managed, ensuring that the thread pools used by database operations are not allowed to block asynchronous IO operations from proceeding.</p>
<p>Lagom takes responsibility of this management, by providing APIs that allow developers to safely use blocking entity manager operations without interfering with asynchronous IO threads. This is provided through the use of a <a href="http://www.lagomframework.com/documentation/1.3.x/java/api/index.html?com/lightbend/lagom/javadsl/persistence/jpa/JpaSession.html"><code>JpaSession</code></a> abstraction.</p>
<p>Lagom also offers specific support for JPA read-side processors, allowing users to seamlessly implement read-sides that focus on the database access logic, rather than having to concentrate on the mechanics of read-sides and offset tracking.</p>
<h2><a href="#getting-started" name="getting-started">Getting started</a></h2>
<p>Lagom is a framework which is designed to ease developers into writing reactive microservices, providing guide rails to ensure that they write services that are resilient and scalable. For this reason, the getting started experience in Lagom is very important, and that&rsquo;s why we&rsquo;ve started investing a lot of effort into the usability of our getting started guides. This effort is on going, but Lagom 1.3 comes with the first glimpse of this work, with a reworked downloads page on the website (now renamed to <a href="http://jroper.github.io/lagom.github.io/get-started.html">Get started</a>), and an improved getting started section in our documentation.</p>
<p>As we continue this effort, you should see an overhaul of the journey we take users on in our documentation, from design and development through to production.</p>
<h2><a href="#improved-test-apis" name="improved-test-apis">Improved test APIs</a></h2>
<p>Another place that we&rsquo;ve put effort into is providing how value test APIs to facilitate in testing Lagom services. In 1.3, a message broker testkit has been introduced, to allow testing of message broker integration. You can read about these APIs for <a href="http://www.lagomframework.com/documentation/1.3.x/java/MessageBrokerTesting.html">Java</a> and <a href="http://www.lagomframework.com/documentation/1.3.x/scala/MessageBrokerTesting.html">Scala</a>.</p>
<h2><a href="#migration" name="migration">Migration</a></h2>
<p>Lagom 1.3 is almost entirely binary and source compatible with 1.2 - we have taken great care to ensure that we only break compatibility when all other options have been exhausted. A short migration guide for upgrading from Lagom 1.2 can be found <a href="http://www.lagomframework.com/documentation/1.3.x/java/Migration13.html">here</a>. In addition, we&rsquo;ve also provided a short guide for the steps necessary for migrating from using the Java API to using the Scala API, which can be found <a href="http://www.lagomframework.com/documentation/1.3.x/scala/Migration13.html">here</a>.</p>]]></content>
          <dc:date>2017-02-24T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Lagom Scala API release candidate 2</title>
          <link rel="alternate" href="http://jroper.github.io/lagom.github.io/blog/lagom-1-3-RC2.html"/>
          <category term="news" scheme="http://jroper.github.io/lagom.github.io/blog/tags/news.html"/>
          <author>
            <name>James Roper</name>
            <uri>https://github.com/jroper</uri>
          </author>
          <id>http://jroper.github.io/lagom.github.io/blog/lagom-1-3-RC2.html</id>
          <updated>2017-02-17T11:00:00.000+11:00</updated>
          <published>2017-02-17T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>We&rsquo;re happy to announce that Lagom 1.3.0-RC2 has been released!</p>
<p>This release candidate includes the new Lagom Scala API, fully documented and with feature parity with the Java API.</p>
<h2><a href="#scala-api-design-philosophy" name="scala-api-design-philosophy">Scala API design philosophy</a></h2>
<p>In Lagom, we want both the Java API and the Scala API to be first class citizens, not one API built on the other, or one API augmented so that it works with the other language. For this reason, we have created two completely separate APIs, these APIs are provided by completely separate libraries, and typically will not be on the classpath at the same time. The namespaces selected for these APIs follow the convention introduced by Akka streams, namely that the Java API has a package name of <code>javadsl</code>, while the Scala API has a package name of <code>scaladsl</code>.</p>
<p>In general, when creating the Scala API, we have typically started with the Java API, and then worked from there to make it more idiomatic for Scala use. Some of the major differences from the Java API include:</p>
<ul>
  <li>Compile time dependency injection. Lagom&rsquo;s Java API builds on Play&rsquo;s Guice support. Lagom&rsquo;s Scala API however uses a lightweight form of the cake pattern to wire dependencies together. This API is designed to work well with <a href="https://github.com/adamw/macwire">Macwire</a>, though Macwire is not required to use it.</li>
  <li>Stronger typed APIs where Scala allows, particularly in the persistent entity API.</li>
  <li>Use of type classes to provide serializers and path parameter extractors, rather than using reflection.</li>
  <li>Use of <a href="https://playframework.com/documentation/2.5.x/ScalaJson">play-json</a> for JSON serialization support.</li>
  <li>Use of macros to implement service clients, rather than dynamic proxies.</li>
</ul>
<h2><a href="#other-features" name="other-features">Other features</a></h2>
<p>Other new features in this release include:</p>
<ul>
  <li>JPA support, including JPA read side processor support.</li>
  <li>New test APIs for testing message broker integration.</li>
  <li>Activator is now deprecated, in favour of the new Giter8 support in sbt 0.13.13.</li>
</ul>
<h2><a href="#sample-apps" name="sample-apps">Sample apps</a></h2>
<p>The Lagom team has been working on an auction system that demonstrates many of the features of Lagom. You can get the Java version <a href="https://github.com/lagom/online-auction-java">here</a> and the Scala version <a href="https://github.com/lagom/online-auction-scala">here</a>. Please be aware that these apps are still a work in progress.</p>
<h2><a href="#migration" name="migration">Migration</a></h2>
<p>There are no major API changes from 1.3.0-RC1, this release primarily just contains bug fixes.</p>]]></content>
          <dc:date>2017-02-17T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Lagom Scala API release candidate</title>
          <link rel="alternate" href="http://jroper.github.io/lagom.github.io/blog/lagom-1-3-RC1.html"/>
          <category term="news" scheme="http://jroper.github.io/lagom.github.io/blog/tags/news.html"/>
          <author>
            <name>James Roper</name>
            <uri>https://github.com/jroper</uri>
          </author>
          <id>http://jroper.github.io/lagom.github.io/blog/lagom-1-3-RC1.html</id>
          <updated>2017-01-24T11:00:00.000+11:00</updated>
          <published>2017-01-24T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>We&rsquo;re happy to announce that Lagom 1.3.0-RC1 has been released!</p>
<p>This release candidate includes the new Lagom Scala API, fully documented and with feature parity with the Java API.</p>
<h2><a href="#scala-api-design-philosophy" name="scala-api-design-philosophy">Scala API design philosophy</a></h2>
<p>In Lagom, we want both the Java API and the Scala API to be first class citizens, not one API built on the other, or one API augmented so that it works with the other language. For this reason, we have created two completely separate APIs, these APIs are provided by completely separate libraries, and typically will not be on the classpath at the same time. The namespaces selected for these APIs follow the convention introduced by Akka streams, namely that the Java API has a package name of <code>javadsl</code>, while the Scala API has a package name of <code>scaladsl</code>.</p>
<p>In general, when creating the Scala API, we have typically started with the Java API, and then worked from there to make it more idiomatic for Scala use. Some of the major differences from the Java API include:</p>
<ul>
  <li>Compile time dependency injection. Lagom&rsquo;s Java API builds on Play&rsquo;s Guice support. Lagom&rsquo;s Scala API however uses a lightweight form of the cake pattern to wire dependencies together. This API is designed to work well with <a href="https://github.com/adamw/macwire">Macwire</a>, though Macwire is not required to use it.</li>
  <li>Stronger typed APIs where Scala allows, particularly in the persistent entity API.</li>
  <li>Use of type classes to provide serializers and path parameter extractors, rather than using reflection.</li>
  <li>Use of <a href="https://playframework.com/documentation/2.5.x/ScalaJson">play-json</a> for JSON serialization support.</li>
  <li>Use of macros to implement service clients, rather than dynamic proxies.</li>
</ul>
<h2><a href="#other-features" name="other-features">Other features</a></h2>
<p>Other new features in this release include:</p>
<ul>
  <li>JPA support, including JPA read side processor support.</li>
  <li>New test APIs for testing message broker integration.</li>
  <li>Activator is now deprecated, in favour of the new Giter8 support in sbt 0.13.13.</li>
</ul>
<h2><a href="#sample-apps" name="sample-apps">Sample apps</a></h2>
<p>The Lagom team has been working on an auction system that demonstrates many of the features of Lagom. You can get the Java version <a href="https://github.com/lagom/online-auction-java">here</a> and the Scala version <a href="https://github.com/lagom/online-auction-scala">here</a>. Please be aware that these apps are still a work in progress.</p>
<h2><a href="#migration" name="migration">Migration</a></h2>
<p>If you were using the Scala API in the M1 release of Lagom 1.3.0, there are some significant changes to the API that have occurred:</p>
<ul>
  <li>Rework of Akka serializers, including removal of <code>Jsonable</code>, and programatic registration of the serializer registry rather than in the configuration file. See <a href="https://github.com/lagom/lagom/pull/399">this pull request</a> for a summary of changes.</li>
  <li>A major type bug has been fixed in persistent entities. As a result of the fix, <code>Persist</code> no longer has a type parameter, and <code>afterPersist</code> callbacks have been split into their own method parameter groups.</li>
  <li><code>LagomDevModeComponents</code> has been moved to the <code>com.lightbend.lagom.scaladsl.devmode</code> package.</li>
  <li>Streamed service calls are now required to declare their <code>Source</code> message types to materialize to <code>NotUsed</code>, where before they were required to materialize to an unbound wildcard.</li>
</ul>]]></content>
          <dc:date>2017-01-24T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Lagom 1.2.2 is ready!</title>
          <link rel="alternate" href="http://jroper.github.io/lagom.github.io/blog/lagom-1-2-2.html"/>
          <category term="news" scheme="http://jroper.github.io/lagom.github.io/blog/tags/news.html"/>
          <author>
            <name>Ignasi Marimon-Clos</name>
            <uri>https://github.com/ignasi35</uri>
          </author>
          <id>http://jroper.github.io/lagom.github.io/blog/lagom-1-2-2.html</id>
          <updated>2017-01-12T11:00:00.000+11:00</updated>
          <published>2017-01-12T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>The Lagom team is proud to announce the availability of the 1.2.2 version. This release provides a bugfix affecting maven users that opted for JDBC persistence instead of Cassandra persistence.</p>
<p>Thanks @dsugden for reporting the issue and helping fix it.</p>
<hr/>
<p>Lagom 1.3 is almost here with a ton of <a href="https://github.com/lagom/lagom/milestone/4">new features</a>, so continue <a href="/get-involved.html">shaping</a> the future of Lagom.</p>]]></content>
          <dc:date>2017-01-12T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Introducing the Lagom Scala API</title>
          <link rel="alternate" href="http://jroper.github.io/lagom.github.io/blog/lagom-scala-api-preview.html"/>
          <category term="news" scheme="http://jroper.github.io/lagom.github.io/blog/tags/news.html"/><category term="scala" scheme="http://jroper.github.io/lagom.github.io/blog/tags/scala.html"/>
          <author>
            <name>James Roper</name>
            <uri>https://github.com/jroper</uri>
          </author>
          <id>http://jroper.github.io/lagom.github.io/blog/lagom-scala-api-preview.html</id>
          <updated>2016-12-09T11:00:00.000+11:00</updated>
          <published>2016-12-09T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>The Lagom team are proud to announce the first milestone release of the Lagom Scala API, Lagom 1.3.0-M1! This release has been many months in the making, and we&rsquo;ve cut this milestone as a preview release in the hope that we can get some early feedback before we cut the final release.</p>
<h2><a href="#design-philosophy" name="design-philosophy">Design philosophy</a></h2>
<p>In Lagom, we want both the Java API and the Scala API to be first class citizens, not one API built on the other, or one API augmented so that it works with the other language. For this reason, we have created two completely separate APIs, these APIs are provided by completely separate libraries, and typically will not be on the classpath at the same time. The namespaces selected for these APIs follow the convention introduced by Akka streams, namely that the Java API has a package name of <code>javadsl</code>, while the Scala API has a package name of <code>scaladsl</code>.</p>
<p>In general, when creating the Scala API, we have typically started with the Java API, and then worked from there to make it more idiomatic for Scala use. Some of the major differences from the Java API include:</p>
<ul>
  <li>Compile time dependency injection. Lagom&rsquo;s Java API builds on Play&rsquo;s Guice support. Lagom&rsquo;s Scala API however uses a lightweight form of the cake pattern to wire dependencies together. This API is designed to work well with <a href="https://github.com/adamw/macwire">Macwire</a>, though Macwire is not required to use it.</li>
  <li>Stronger typed APIs where Scala allows, particularly in the persistent entity API.</li>
  <li>Use of type classes to provide serializers and path parameter extractors, rather than using reflection.</li>
  <li>Use of <a href="https://playframework.com/documentation/2.5.x/ScalaJson">play-json</a> for JSON serialization support.</li>
  <li>Use of macros to implement service clients, rather than dynamic proxies.</li>
</ul>
<h2><a href="#status" name="status">Status</a></h2>
<p>The following APIs and features are complete:</p>
<ul>
  <li>Service API</li>
  <li>Message broker API with Kafka implementation</li>
  <li>Persistence API with both Cassandra and JDBC implmentations</li>
  <li>Dev mode</li>
  <li>Play integration</li>
</ul>
<p>Meanwhile, the following things are left to be done:</p>
<ul>
  <li>ConductR integration</li>
  <li>Some testkit APIs</li>
  <li>Much of the documentation</li>
</ul>
<p>To create a new Lagom Scala project, using sbt 0.13.13, run:</p>
<pre class="prettyprint"><code>$ sbt new lagom/lagom-scala.g8
</code></pre>
<p>For a reasonably comprehensive demonstration of the Lagom Scala API, you can checkout the <a href="https://github.com/lagom/online-auction-scala">online auction sample app</a>. Note that this is a work in progress, some things aren&rsquo;t complete yet. Of course, the <a href="http://www.lagomframework.com/documentation/1.3.x/scala/Home.html">documentation</a> is also a good place to go.</p>
<p>As this is a milestone release, the API is still considered experimental, and will likely change before the final release. Hence, we recommend not using it for any production services yet.</p>]]></content>
          <dc:date>2016-12-09T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Lagom 1.2.1 is ready!</title>
          <link rel="alternate" href="http://jroper.github.io/lagom.github.io/blog/lagom-1-2-1.html"/>
          <category term="news" scheme="http://jroper.github.io/lagom.github.io/blog/tags/news.html"/>
          <author>
            <name>Ignasi Marimon-Clos</name>
            <uri>https://github.com/ignasi35</uri>
          </author>
          <id>http://jroper.github.io/lagom.github.io/blog/lagom-1-2-1.html</id>
          <updated>2016-12-07T11:00:00.000+11:00</updated>
          <published>2016-12-07T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>The Lagom team is proud to announce the availability of the 1.2.1 version. This release provides several bugfixes and a performance enhancement.</p>
<p>It&rsquo;s been a month since releasing 1.2.0 and the <a href="https://github.com/lagom/lagom/issues">mailing list</a> and Lagom&rsquo;s <a href="https://gitter.im/lagom/lagom">Gitter channel</a> have been <em>on fire</em>. Many are already developing their microservice-based solutions using Lagom, but Lagom is not (yet) free of bugs and the community has been great at helping spot some of these bugs both on documentation or the code itself. This release addresses <a href="https://github.com/lagom/lagom/milestone/5?closed=1">some of these issues</a> improving documentation and performance, and fixing a regression introduced when releasing 1.2.0. Don&rsquo;t forget to use Lagom&rsquo;s <a href="https://github.com/lagom/lagom/issues">issue tracker</a> to report and contribute to fixing issues.</p>
<p>Thanks to all of you that reported and contributed on making this release possible.</p>
<hr/>
<p>Lagom 1.3 is almost here with a ton of <a href="https://github.com/lagom/lagom/milestone/4">new features</a>, so continue <a href="/get-involved.html">shaping</a> the future of Lagom.</p>]]></content>
          <dc:date>2016-12-07T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Lagom 1.2 is released!</title>
          <link rel="alternate" href="http://jroper.github.io/lagom.github.io/blog/lagom-1-2.html"/>
          <category term="news" scheme="http://jroper.github.io/lagom.github.io/blog/tags/news.html"/>
          <author>
            <name>Tim Moore</name>
            <uri>https://github.com/TimMoore</uri>
          </author>
          <id>http://jroper.github.io/lagom.github.io/blog/lagom-1-2.html</id>
          <updated>2016-11-08T11:00:00.000+11:00</updated>
          <published>2016-11-08T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>The Lagom team is proud to announce the release of Lagom 1.2! This release introduces support for message brokers, JDBC, and an overhaul of read sides.</p>
<p>If you&rsquo;ve been following along with the RCs, there have only been minor changes since RC2, but if you&rsquo;re upgrading from 1.1.0 or earlier, please be sure to follow the <a href="//www.lagomframework.com/documentation/1.2.x/java/Migration12.html">migration guide</a>, as there are some changes you&rsquo;ll need to make to your project.</p>
<p>Here&rsquo;s a recap of the major new features that were announced with the release candidates. You can see more details in the <a href="/changelog.html">change log</a> or on <a href="https://github.com/lagom/lagom/issues?utf8=%E2%9C%93&q=milestone%3A1.2.0">GitHub</a>.</p>
<hr/>
<h2><a href="#message-broker-support" name="message-broker-support">Message broker support</a></h2>
<p>The biggest feature of Lagom 1.2 is message broker support. This means Lagom now allows both direct streaming of messages between services, as well as streaming of messages through a broker.</p>
<p>Lagom&rsquo;s message broker support does not require any one particular message broker implementation, however out of the box we have only implemented support for Kafka. Kafka is a popular very scalable message broker, and fits well in the Lagom architectural philosophy.</p>
<p>Lagom will automatically run Kafka for you when you run the <code>runAll</code> command, both in Maven and sbt, which makes getting started with a project that uses Kafka very simple. It also abstracts the publishing, partitioning, consuming and failure handling of messaging away from you, so you can focus primarily on your business concerns.</p>
<p>As with Lagom <code>ServiceCall</code>&rsquo;s, which provide a protocol agnostic way of directly communicating with other services that maps down onto HTTP, Lagom provides a new <code>Topic</code> abstraction, which represents a topic that one service publishes, and one or more services consume. Through the use of service descriptors, Lagom allows all the serialization and deserialization logic for these messages to be captured and shared between services.</p>
<p>As a first and primary use case, we have targetted publishing a persistent entity event stream for the source of topics. This allows the implementation of remote read sides, as well as provides a great basis for guaranteed at least once delivery of events between services.</p>
<p>To explore more of Lagom&rsquo;s message broker support, read the <a href="http://www.lagomframework.com/documentation/1.2.x/java/MessageBroker.html">documentation</a>.</p>
<h2><a href="#jdbc-support" name="jdbc-support">JDBC support</a></h2>
<p>Feedback that we got from many potential users was that in order to introduce Lagom into their organisation, it would need to have support for using their existing relational database infrastructure. While a relational database is often not the best choice, particularly for storing event sourced entities, it&rsquo;s not necessarily a bad choice. We felt that having no JDBC support was an unnecessary blocker to organisations getting the benefits of a Lagom based architecture.</p>
<p>Lagom supports JDBC both for <a href="http://www.lagomframework.com/documentation/1.2.x/java/PersistentEntityRDBMS.html">storing persistent entities</a>, as well as for implementing <a href="http://www.lagomframework.com/documentation/1.2.x/java/ReadSideRDBMS.html">read sides</a>.</p>
<h2><a href="#read-side-overhaul" name="read-side-overhaul">Read side overhaul</a></h2>
<p>Lagom&rsquo;s read side support has been overhauled. There are three major parts to this. First of all, read sides that talk to any data store can now be implemented - previously the read side processor API was specific to Cassandra. We still provide a Cassandra specific utility for building Cassandra read sides, as well as a new JDBC specific utility for building JDBC read sides, but these are just helpers for building read sides, you can build a read side in anything. Documentation for the new read side API can be found <a href="http://www.lagomframework.com/documentation/1.2.x/java/ReadSide.html">here</a>.</p>
<p>The second is that read sides can now be sharded, by tagging persistent entity events with sharded tags. Lagom&rsquo;s read side processors now declare a list of tags that they process, rather than just one, and Lagom will automatically distribute the processing of these tags across the cluster. This is great for services with a high throughput of events, or when event processing can be very slow or expensive.</p>
<p>The final feature is that both the Cassandra and JDBC specific read side support utilities provide automatic offset tracking, meaning that your read side processors no longer need to explicitly load and persist offsets. This makes it much simpler to implement a read side processor. Documentation is available for both the <a href="http://www.lagomframework.com/documentation/1.2.x/java/ReadSideCassandra.html">Cassandra read side support</a> and the <a href="http://www.lagomframework.com/documentation/1.2.x/java/ReadSideRDBMS.html">JDBC read side support</a>.</p>
<p>The existing Cassandra read side support is still supported, but is deprecated.</p>
<hr/>
<p>Thanks to everyone who provided feedback on the release candidates. There are more exciting things planned for Lagom 1.3, so please <a href="/get-involved.html">Get Involved</a> and help shape the future of Lagom.</p>]]></content>
          <dc:date>2016-11-08T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Lagom 1.2.0 is almost here!</title>
          <link rel="alternate" href="http://jroper.github.io/lagom.github.io/blog/lagom-1-2-RC2.html"/>
          <category term="news" scheme="http://jroper.github.io/lagom.github.io/blog/tags/news.html"/>
          <author>
            <name>James Roper</name>
            <uri>https://github.com/jroper</uri>
          </author>
          <id>http://jroper.github.io/lagom.github.io/blog/lagom-1-2-RC2.html</id>
          <updated>2016-10-25T11:00:00.000+11:00</updated>
          <published>2016-10-25T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>We&rsquo;re happy to announce that Lagom 1.2.0-RC2 has been released!</p>
<p>This release has a small reworking of the read side event tags so that events can be automatically sharded by Lagom. Previously, your <code>aggregateTag</code> function had to compute it&rsquo;s own sharded tags if you wanted to shard your read sides. Now, you can simply return a <a href="//www.lagomframework.com/documentation/1.2.x/java/api/index.html?com/lightbend/lagom/javadsl/persistence/AggregateEventTag.html#sharded-java.lang.Class-int-">single meta tag</a> to say that the events should be sharded, and how many shards you want, and Lagom will handle the sharding for you. Read <a href="//www.lagomframework.com/documentation/1.2.x/java/ReadSide.html#event-tags">the documentation</a> for more details.</p>
<p>We&rsquo;ve also made some minor improvements around how Kafka message keys are <a href="//www.lagomframework.com/documentation/1.2.x/java/MessageBrokerApi.html#Partitioning-topics">extracted from messages</a>, and provided topic testing support in the testkit.</p>
<p>On the documentation side, there&rsquo;s more documentation for using and testing Kafka, and most importantly, we&rsquo;ve written a <a href="//www.lagomframework.com/documentation/1.2.x/java/Migration12.html">migration guide</a>, outlining any changes you may need to make in order to move from Lagom 1.1 to Lagom 1.2.</p>
<p>Lagom 1.2.0 should be released very soon, so stay tuned!</p>]]></content>
          <dc:date>2016-10-25T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>What's next in Lagom 1.2?</title>
          <link rel="alternate" href="http://jroper.github.io/lagom.github.io/blog/whats-next-in-lagom-1-2.html"/>
          <category term="news" scheme="http://jroper.github.io/lagom.github.io/blog/tags/news.html"/>
          <author>
            <name>James Roper</name>
            <uri>https://github.com/jroper</uri>
          </author>
          <id>http://jroper.github.io/lagom.github.io/blog/whats-next-in-lagom-1-2.html</id>
          <updated>2016-09-30T10:00:00.000+10:00</updated>
          <published>2016-09-30T10:00:00.000+10:00</published>
          <content type="html"><![CDATA[<p>Today we released Lagom 1.2.0-RC1, the first release candidate for the upcoming Lagom 1.2. This release has three exciting new features that we&rsquo;d like to tell you about.</p>
<h2><a href="#message-broker-support" name="message-broker-support">Message broker support</a></h2>
<p>The biggest feature of Lagom 1.2 is message broker support. This means Lagom now allows both direct streaming of messages between services, as well as streaming of messages through a broker.</p>
<p>Lagom&rsquo;s message broker support does not require any one particular message broker implementation, however out of the box we have only implemented support for Kafka. Kafka is a popular very scalable message broker, and fits well in the Lagom architectural philosophy.</p>
<p>Lagom will automatically run Kafka for you when you run the <code>runAll</code> command, both in Maven and sbt, which makes getting started with a project that uses Kafka very simple. It also abstracts the publishing, partitioning, consuming and failure handling of messaging away from you, so you can focus primarily on your business concerns.</p>
<p>As with Lagom <code>ServiceCall</code>&rsquo;s, which provide a protocol agnostic way of directly communicating with other services that maps down onto HTTP, Lagom provides a new <code>Topic</code> abstraction, which represents a topic that one service publishes, and one or more services consume. Through the use of service descriptors, Lagom allows all the serialization and deserialization logic for these messages to be captured and shared between services.</p>
<p>As a first and primary use case, we have targetted publishing a persistent entity event stream for the source of topics. This allows the implementation of remote read sides, as well as provides a great basis for guaranteed at least once delivery of events between services.</p>
<p>To explore more of Lagom&rsquo;s message broker support, read the <a href="http://www.lagomframework.com/documentation/1.2.x/java/MessageBroker.html">documentation</a>.</p>
<h2><a href="#jdbc-support" name="jdbc-support">JDBC support</a></h2>
<p>Feedback that we got from many potential users was that in order to introduce Lagom into their organisation, it would need to have support for using their existing relational database infrastructure. While a relational database is often not the best choice, particularly for storing event sourced entities, it&rsquo;s not necessarily a bad choice. We felt that having no JDBC support was an unnecessary blocker to organisations getting the benefits of a Lagom based architecture.</p>
<p>Lagom supports JDBC both for <a href="http://www.lagomframework.com/documentation/1.2.x/java/PersistentEntityRDBMS.html">storing persistent entities</a>, as well as for implementing <a href="http://www.lagomframework.com/documentation/1.2.x/java/ReadSideRDBMS.html">read-sides</a>.</p>
<h2>Read-side overhaul</h2>
<p>Lagom&rsquo;s read-side support has been overhauled. There are three major parts to this. First of all, read sides that talk to any data store can now be implemented - previously the read side processor API was specific to Cassandra. We still provide a Cassandra specific utility for building Cassandra read-sides, as well as a new JDBC specific utility for building JDBC read-sides, but these are just helpers for building read-sides, you can build a read-side in anything. Documentation for the new read-side API can be found <a href="http://www.lagomframework.com/documentation/1.2.x/java/ReadSide.html">here</a>.</p>
<p>The second is that read-sides can now be sharded, by tagging persistent entity events with sharded tags. Lagom&rsquo;s read side processors now declare a list of tags that they process, rather than just one, and Lagom will automatically distribute the processing of these tags across the cluster. This is great for services with a high throughput of events, or when event processing can be very slow or expensive.</p>
<p>The final feature is that both the Cassandra and JDBC specific read side support utilities provide automatic offset tracking, meaning that your read side processors no longer need to explicitly load and persist offsets. This makes it much simpler to implement a read side processor. Documentation is available for both the <a href="http://www.lagomframework.com/documentation/1.2.x/java/ReadSideCassandra.html">Cassandra read-side support</a> and the <a href="http://www.lagomframework.com/documentation/1.2.x/java/ReadSideRDBMS.html">JDBC read-side support</a>.</p>
<p>The existing Cassandra read-side support is still supported, but is deprecated.</p>
<h2>Onwards to 1.2.0</h2>
<p>We are hoping to release Lagom 1.2.0 in the coming month, so please check it out, jump on the <a href="https://gitter.im/lagom/lagom">Gitter channel</a> and give us feedback!</p>]]></content>
          <dc:date>2016-09-30T10:00:00.000+10:00</dc:date>
        </entry><entry>
          <title>Lagom 1.1 is released!</title>
          <link rel="alternate" href="http://jroper.github.io/lagom.github.io/blog/lagom-1-1.html"/>
          <category term="news" scheme="http://jroper.github.io/lagom.github.io/blog/tags/news.html"/>
          <author>
            <name>James Roper</name>
            <uri>https://github.com/jroper</uri>
          </author>
          <id>http://jroper.github.io/lagom.github.io/blog/lagom-1-1.html</id>
          <updated>2016-09-21T10:00:00.000+10:00</updated>
          <published>2016-09-21T10:00:00.000+10:00</published>
          <content type="html"><![CDATA[<p>The Lagom team are proud to announce the release of Lagom 1.1! The primary new feature of Lagom 1.1 is maven support - this includes support for running the Lagom development environment in Maven.</p>
<p>Although running many services with hot reloads in Maven is not a traditional thing to do, as much as possible the Lagom Maven plugin makes idiomatic usage of Maven, meaning that it&rsquo;s still compatible with whatever Maven plugins or tooling that you use, including IDEs, code generators, testing tools and so on.</p>
<p>Lagom&rsquo;s Maven integration also supports starting a full system environment as part of your integration tests, so you can do comprehensive testing of inter service communication.</p>
<p>You can get started today with a Lagom starter app by running:</p>
<pre class="prettyprint"><code>mvn archetype:generate -DarchetypeGroupId=com.lightbend.lagom \
  -DarchetypeArtifactId=maven-archetype-lagom-java -DarchetypeVersion=1.1.0
</code></pre>
<p>For more details, read the documentation on <a href="http://www.lagomframework.com/documentation/1.1.x/java/GettingStartedMaven.html">Getting started with Maven</a>. Enjoy!</p>]]></content>
          <dc:date>2016-09-21T10:00:00.000+10:00</dc:date>
        </entry>
    </feed>